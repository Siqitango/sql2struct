package mysqlparser

import (
	"bytes"
	"github.com/gangming/sql2struct/utils"
	"strings"
	"text/template"
)

var tmpl = `// Code generated by sql2struct. DO NOT EDIT.
package {{.Package}}

{{if .ContainsTimeField}}import "time" {{end}}

//{{ .UpperCamelCaseName}} {{.Table.Comment}}
type {{ .UpperCamelCaseName}} struct {
{{range .Fields}} {{.UpperCamelCaseName}}  {{.Type}} {{.Tag}} {{if .Comment}} // {{.Comment}} {{end}}
{{end}}}

func (t *{{.UpperCamelCaseName}}) TableName() string {
    return "{{.Table.Name}}"
}
`
var MysqlType2GoType = map[string]string{
	"int":       "int64",
	"tinyint":   "uint8",
	"bigint":    "int64",
	"varchar":   "string",
	"text":      "string",
	"date":      "time.Time",
	"time":      "time.Time",
	"datetime":  "time.Time",
	"timestamp": "time.Time",
	"json":      "string",
}

type Table struct {
	Name               string  `sql:"name"`
	UpperCamelCaseName string  `sql:"upper_camel_case_name"`
	Comment            string  `sql:"comment"`
	Fields             []Field `sql:"fields"`
	ContainsTimeField  bool    `sql:"contains_time"`
}
type Field struct {
	IsPK               bool   `json:"is_pk"`
	Name               string `json:"name"`
	UpperCamelCaseName string `json:"upper_camel_case_name"`
	Type               string `json:"type"`
	Comment            string `json:"comment"`
	DefaultValue       string `json:"default_value"`
	Tag                string `json:"tag"`
}

func ParseMysqlDDL(s string) (Table, error) {
	lines := strings.Split(s, "\n")
	var table Table
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.Contains(line, "CREATE TABLE") {
			tableName := strings.Split(line, "`")[1]
			table.Name = tableName
			table.UpperCamelCaseName = utils.Underline2UpperCamelCase(tableName)
			continue
		}
		if strings.Contains(line, "ENGINE") {
			table.Comment = strings.Trim(strings.Split(line, "COMMENT='")[1], "'")
			continue
		}
		if line[0] == '`' {
			field := Field{}
			field.Name = strings.Split(line, "`")[1]
			field.UpperCamelCaseName = utils.Underline2UpperCamelCase(field.Name)
			field.Type = strings.TrimRightFunc(strings.Split(line, " ")[1], func(r rune) bool {
				return r < 'a' || r > 'z'
			})
			field.Type = MysqlType2GoType[field.Type]
			if strings.Contains(field.Type, "time") {
				table.ContainsTimeField = true
			}
			if strings.Contains(line, "COMMENT") {
				field.Comment = strings.Trim(strings.Split(line, "COMMENT '")[1], "',")
			}
			if strings.Contains(line, "DEFAULT'") {
				field.DefaultValue = strings.Split(line, "DEFAULT ")[1]
			}
			if strings.Contains(line, "PRIMARY KEY") {
				field.IsPK = true
			}

			table.Fields = append(table.Fields, field)

		}

	}
	return table, nil
}
func (t *Table) GenerateCode() string {
	tmpl = strings.Replace(tmpl, "{{.Package}}", "model", -1)
	tmpl = strings.Replace(tmpl, "{{.Table.Name}}", t.Name, -1)
	tmpl = strings.Replace(tmpl, "{{.Table.Comment}}", t.Comment, -1)
	for i, field := range t.Fields {
		tag := "`gorm:\"column:" + field.Name + "\""
		if field.IsPK {
			tag += ";primary_key\" "
		}
		if field.DefaultValue != "" {
			tag += ";default:" + field.DefaultValue + "\""
		}
		tag += " json:\"" + field.Name + "\"`"
		t.Fields[i].Tag = tag
	}
	tl := template.Must(template.New("tmpl").Parse(tmpl))
	var res bytes.Buffer
	err := tl.Execute(&res, t)
	if err != nil {
		panic(err)
	}
	return res.String()
}
